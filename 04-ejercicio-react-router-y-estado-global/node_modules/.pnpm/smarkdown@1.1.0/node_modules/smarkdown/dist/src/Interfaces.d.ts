import { Renderer } from './Renderer';
export interface BaseBlockRules {
    _comment: RegExp;
    blockquote: RegExp;
    bullet: RegExp;
    code: RegExp;
    def: RegExp;
    fences: RegExp;
    heading: RegExp;
    hr: RegExp;
    html: RegExp;
    item: RegExp;
    lheading: RegExp;
    list: RegExp;
    newline: RegExp;
    paragraph?: RegExp;
    text: RegExp;
    _paragraph: RegExp;
}
export interface PedanticBlockRules extends BaseBlockRules {
}
export interface GfmBlockRules extends BaseBlockRules {
    checkbox: RegExp;
    fences: RegExp;
    nptable: RegExp;
    table: RegExp;
}
export interface ExtraBlockRules extends GfmBlockRules {
    footnote: RegExp;
}
export declare type BlockRulesTypes = BaseBlockRules | GfmBlockRules | ExtraBlockRules;
export declare type BlockRulesType = keyof (BlockRulesTypes);
export interface Link {
    href: string;
    title: string;
}
export interface Links {
    [key: string]: Link;
}
export declare enum TokenType {
    blockquoteEnd = 1,
    blockquoteStart = 2,
    code = 3,
    footnote = 4,
    heading = 5,
    hr = 6,
    html = 7,
    listEnd = 8,
    listItemEnd = 9,
    listItemStart = 10,
    listStart = 11,
    looseItemEnd = 12,
    looseItemStart = 13,
    paragraph = 14,
    raw = 15,
    space = 16,
    table = 17,
    text = 18
}
export declare type Align = 'center' | 'left' | 'right';
export interface Token {
    align?: Align[];
    cells?: string[][];
    depth?: number;
    ends?: string;
    escaped?: boolean;
    execArr?: RegExpExecArray;
    header?: string[];
    lang?: string;
    loose?: boolean;
    ordered?: boolean;
    pre?: boolean;
    start?: string | number;
    text?: string;
    type: number | string;
    checked?: boolean | null;
    footnote?: string;
    footnotes?: string[];
    refname?: string;
    codeBlockStyle?: string;
}
export interface BaseInlineRules {
    _escapes: RegExp;
    _label: RegExp;
    autolink: RegExp;
    br: RegExp;
    code: RegExp;
    em: RegExp;
    escape: RegExp;
    link: RegExp;
    nolink: RegExp;
    reflink: RegExp;
    strong: RegExp;
    tag: RegExp;
    text: RegExp;
}
export interface PedanticInlineRules extends BaseInlineRules {
}
export interface GfmInlineRules extends BaseInlineRules {
    _backpedal: RegExp;
    del: RegExp;
    url: RegExp;
}
export interface BreaksInlineRules extends GfmInlineRules {
}
export interface ExtraInlineRules extends BreaksInlineRules {
    fnref: RegExp;
}
export interface ExtraMoreInlineRules {
    fnref: RegExp;
}
export declare type InlineRulesTypes = BaseInlineRules | PedanticInlineRules | GfmInlineRules | BreaksInlineRules | ExtraInlineRules;
export declare type InlineRulesType = keyof (InlineRulesTypes);
export declare class Options {
    baseUrl?: string;
    breaks?: boolean;
    disabledRules?: string[];
    extra?: boolean;
    gfm?: boolean;
    headerId?: boolean | string;
    headerPrefix?: string;
    highlight?: (code: string, lang?: string) => string;
    langAttribute?: boolean;
    langPrefix?: string;
    linksInNewTab?: boolean | Function;
    mangle?: boolean;
    pedantic?: boolean;
    renderer?: Renderer;
    sanitize?: boolean;
    sanitizer?: (text: string) => string;
    silent?: boolean;
    smartLists?: boolean;
    smartypants?: boolean;
    trimLinkText?: Function;
    xhtml?: boolean;
    escape?: (html: string, encode?: boolean) => string;
    unescape?: (html: string) => string;
    slug?: (str: string, isUnique?: boolean) => string;
    rtrim?: (str: string, c: string, invert?: boolean) => string;
    resolveUrl?: (base: string, href: string) => string;
    cleanUrl?: (sanitize: boolean, base: string, href: string) => string;
    nop?: boolean;
}
export interface LexerReturns {
    links: Links;
    tokens: Token[];
}
export interface EmptyObject {
    [key: string]: any;
}
export declare type NewRenderer = (execArr?: RegExpExecArray) => string;
export interface BlockRenderer {
    renderer: NewRenderer;
    type: string;
}
export declare type InlineRuleOptions = {
    checkPreChar?: Function;
    priority?: number;
};
export declare type BlockRuleOptions = {
    priority?: number;
};
export interface InlineRule {
    breakChar: string;
    options: InlineRuleOptions;
    render: Function;
    rule: RegExp;
    type: string;
}
export interface BlockRule {
    options: BlockRuleOptions;
    rule: RegExp;
    type: string;
}
export interface TablecellFlags {
    align?: Align;
    header?: boolean;
}
export interface Footnotes {
    [key: string]: string;
}
